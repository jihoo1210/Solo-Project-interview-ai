# 프로덕션 배포 트러블슈팅 모음

## 목차
1. [AuthController 리다이렉트 URL 하드코딩 문제](#1-authcontroller-리다이렉트-url-하드코딩-문제)
2. [TossPayments SDK 버전 불일치 문제](#2-tosspayments-sdk-버전-불일치-문제)
3. [백엔드/프론트엔드 DTO 필드명 불일치 문제](#3-백엔드프론트엔드-dto-필드명-불일치-문제)
4. [TossPayments v2 메서드명 변경 문제](#4-tosspayments-v2-메서드명-변경-문제)

---

## 1. AuthController 리다이렉트 URL 하드코딩 문제

### 증상
- 로컬에서는 이메일 인증/회원탈퇴 후 정상 리다이렉트
- 배포 환경에서 `localhost:5173`으로 리다이렉트되어 페이지 접근 불가

### 원인
`AuthController`에서 리다이렉트 URL이 하드코딩되어 있었음:

```java
// 문제 코드
response.sendRedirect("http://localhost:5173/verify-email?success=true");
```

### 해결
`@Value`로 환경변수에서 URL을 주입받도록 변경:

```java
@Value("${app.frontend-url:http://localhost:5173}")
private String frontendUrl;

@GetMapping("/verify-email")
public void verifyEmail(@RequestParam("token") String token, HttpServletResponse response) throws IOException {
    try {
        authService.verifyEmail(token);
        response.sendRedirect(frontendUrl + "/verify-email?success=true");
    } catch (Exception e) {
        String errorMessage = URLEncoder.encode(e.getMessage(), StandardCharsets.UTF_8);
        response.sendRedirect(frontendUrl + "/verify-email?success=false&error=" + errorMessage);
    }
}
```

### 교훈
- **URL, 포트, 호스트 등은 절대 하드코딩하지 말 것**
- 환경별로 다른 값은 `application.yml`에서 관리
- `@Value`나 `@ConfigurationProperties`로 주입받아 사용

---

## 2. TossPayments SDK 버전 불일치 문제

### 증상
```
window.TossPayments(...).payment is not a function
```

### 원인
SDK 버전과 API 호출 방식의 불일치:

| SDK 버전 | URL | API 방식 |
|----------|-----|----------|
| v1 | `js.tosspayments.com/v1/payment` | `tossPayments.requestBillingKeyAuth()` |
| v2 | `js.tosspayments.com/v2/standard` | `tossPayments.payment().requestBillingKeyAuth()` |

코드에서는 v2 방식(`.payment()`)을 사용하는데, SDK는 v1을 로드하고 있었음.

### 문제 코드
```html
<!-- index.html - v1 SDK 로드 -->
<script src="https://js.tosspayments.com/v1/payment"></script>
```

```typescript
// PaymentPage.tsx - v2 방식 사용
const tossPayments = window.TossPayments(clientKey);
const payment = tossPayments.payment({ customerKey: prepareResponse.customerKey }); // v1에는 없는 메서드!
await payment.requestBillingKeyAuth('카드', { ... });
```

### 해결
SDK를 v2로 업그레이드:

```html
<!-- index.html -->
<script src="https://js.tosspayments.com/v2/standard"></script>
```

### v1 vs v2 API 비교

**v1 방식:**
```typescript
const tossPayments = window.TossPayments(clientKey);
await tossPayments.requestBillingKeyAuth('카드', {
  customerKey: 'CUSTOMER_123',
  successUrl: '...',
  failUrl: '...',
});
```

**v2 방식:**
```typescript
const tossPayments = window.TossPayments(clientKey);
const payment = tossPayments.payment({ customerKey: 'CUSTOMER_123' });
await payment.requestBillingAuth({
  method: 'CARD',
  successUrl: '...',
  failUrl: '...',
});
```

### 교훈
- **외부 SDK 사용 시 버전과 API 문서를 반드시 확인**
- 로컬과 배포 환경에서 같은 SDK 버전을 사용하는지 확인
- SDK 업그레이드 시 Breaking Changes 확인 필수

---

## 3. 백엔드/프론트엔드 DTO 필드명 불일치 문제

### 증상
```
customerKey 필수 파라미터가 누락되었습니다.
```

콘솔 로그:
```javascript
prepareResponse: {orderId: 'CUSTOMER_38', amount: 9900, ...}
// customerKey가 아닌 orderId로 응답됨
```

### 원인
백엔드 DTO와 프론트엔드 타입의 필드명이 다름:

**백엔드 (PaymentPrepareResponse.java):**
```java
public record PaymentPrepareResponse(
    String orderId,  // 문제: orderId
    Integer amount,
    String orderName,
    String customerEmail,
    String customerName
) {}
```

**프론트엔드 (types/index.ts):**
```typescript
export interface PaymentPrepareResponse {
  customerKey: string;  // 기대: customerKey
  amount: number;
  orderName: string;
  customerEmail: string;
  customerName: string;
}
```

**서비스 코드 (PaymentService.java):**
```java
String customerKey = "CUSTOMER_" + user.getId();
return new PaymentPrepareResponse(
    customerKey,  // 주석: "orderId 대신 customerKey 사용" - 하지만 DTO 필드명은 orderId
    planType.getPrice(),
    // ...
);
```

서비스에서는 `customerKey`라고 주석까지 달아놨지만, DTO 필드명이 `orderId`여서 JSON 응답이 `{"orderId": "CUSTOMER_38"}`로 나감.

### 해결
백엔드 DTO 필드명을 `customerKey`로 변경:

```java
public record PaymentPrepareResponse(
    String customerKey,  // orderId → customerKey
    Integer amount,
    String orderName,
    String customerEmail,
    String customerName
) {}
```

### 교훈
- **백엔드/프론트엔드 DTO 필드명은 정확히 일치해야 함**
- TypeScript 타입만 정의하면 컴파일 타임에는 잡히지 않음 (런타임 에러)
- API 응답 구조 변경 시 프론트엔드 타입도 함께 확인
- **주석과 실제 코드가 일치하는지 확인** (주석은 customerKey라고 해놓고 필드명은 orderId)

### 디버깅 방법
```typescript
// 서버 응답을 콘솔에 출력
const prepareResponse = await preparePayment('PREMIUM_MONTHLY');
console.log('prepareResponse:', prepareResponse);

// 필수 필드 검증 추가
if (!prepareResponse?.customerKey) {
  throw new Error('customerKey가 없습니다. 서버 응답을 확인해주세요.');
}
```

---

## 4. TossPayments v2 메서드명 변경 문제

### 증상
```
window.TossPayments(...).payment(...).requestBillingKeyAuth is not a function
```

### 원인
TossPayments v2 SDK에서 빌링키 발급 메서드명이 변경됨:

| v1 | v2 |
|----|-----|
| `requestBillingKeyAuth('카드', {...})` | `requestBillingAuth({method: 'CARD', ...})` |

- 메서드명: `requestBillingKeyAuth` → `requestBillingAuth`
- 파라미터: 첫 번째 인자로 결제 수단을 별도로 전달 → `method` 속성으로 객체에 포함

### 문제 코드
```typescript
// v1 스타일 (v2 SDK에서 동작 안 함)
await payment.requestBillingKeyAuth('카드', {
  scope: 'BILLING',
  successUrl: '...',
  failUrl: '...',
  customerEmail: '...',
  customerName: '...',
});
```

### 해결
```typescript
// v2 스타일 (올바른 방식)
await payment.requestBillingAuth({
  method: 'CARD',  // 결제 수단을 객체 내부로 이동
  successUrl: `${window.location.origin}/payment/success`,
  failUrl: `${window.location.origin}/payment/fail`,
  customerEmail: prepareResponse.customerEmail,
  customerName: prepareResponse.customerName,
});
```

### v1 vs v2 빌링키 발급 API 전체 비교

**v1 (js.tosspayments.com/v1/payment):**
```typescript
const tossPayments = window.TossPayments(clientKey);
await tossPayments.requestBillingKeyAuth('카드', {
  customerKey: 'CUSTOMER_123',
  successUrl: '...',
  failUrl: '...',
});
```

**v2 (js.tosspayments.com/v2/standard):**
```typescript
const tossPayments = window.TossPayments(clientKey);
const payment = tossPayments.payment({ customerKey: 'CUSTOMER_123' });
await payment.requestBillingAuth({
  method: 'CARD',
  successUrl: '...',
  failUrl: '...',
  customerEmail: '...',
  customerName: '...',
});
```

### 주요 차이점 요약
1. **`payment()` 객체 생성**: v2는 `customerKey`를 `payment()` 생성 시 전달
2. **메서드명 변경**: `requestBillingKeyAuth` → `requestBillingAuth`
3. **결제 수단 전달 방식**: 별도 인자 → `method` 속성
4. **scope 제거**: v2에서는 `scope: 'BILLING'` 불필요

### 교훈
- **외부 SDK 버전 업그레이드 시 API 변경사항을 꼼꼼히 확인**
- 메서드명이 비슷하다고 동일하게 동작한다고 가정하지 말 것
- 공식 문서의 예제 코드를 참고하여 정확한 사용법 확인
- 에러 메시지의 "is not a function"은 해당 메서드가 존재하지 않음을 의미

---

## 전체 체크리스트

### 배포 전 확인사항
- [ ] 하드코딩된 localhost URL이 없는지 검색: `grep -r "localhost" src/`
- [ ] 환경변수가 프로덕션 값으로 설정되어 있는지 확인
- [ ] 외부 SDK 버전이 코드와 일치하는지 확인
- [ ] 백엔드/프론트엔드 DTO 필드명이 일치하는지 확인
- [ ] API 응답 구조가 프론트엔드 타입과 일치하는지 확인

### 디버깅 팁
1. **브라우저 콘솔**에서 API 응답 확인
2. **Network 탭**에서 실제 요청/응답 확인
3. **console.log**로 중간 값 확인
4. 에러 메시지를 **정확히** 읽기 (어떤 값이 없는지, 어떤 함수가 없는지)

---

## 참고
- [TossPayments SDK v2 문서](https://docs.tosspayments.com/reference/widget-sdk)
- [Spring Boot @Value 어노테이션](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config)
