# 토스페이먼츠 정기결제 구현 절차

이 문서는 토스페이먼츠 정기결제(빌링) 시스템을 Spring Boot + React로 구현하는 절차를 설명합니다.

## 전체 아키텍처

```
[프론트엔드]                    [백엔드]                      [토스페이먼츠]
     |                            |                              |
     |-- 1. 결제 버튼 클릭 ------->|                              |
     |                            |-- 2. customerKey 생성 ------->|
     |<-- 3. customerKey 반환 ----|                              |
     |                            |                              |
     |-- 4. SDK로 결제창 호출 ------------------------------------>|
     |                            |                              |
     |<-- 5. authKey 전달 (redirect) ----------------------------|
     |                            |                              |
     |-- 6. authKey로 빌링키 발급 요청 -->|                       |
     |                            |-- 7. 빌링키 발급 API -------->|
     |                            |<-- 8. billingKey 반환 -------|
     |                            |-- 9. 빌링키로 결제 요청 ----->|
     |                            |<-- 10. 결제 완료 -------------|
     |<-- 11. 결제 완료 응답 -----|                              |
```

---

## Step 1: 백엔드 설정

### 1.1 의존성 추가 (build.gradle)

```gradle
dependencies {
    // Spring Web Client (API 호출용)
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
}
```

### 1.2 환경변수 설정 (application.yml)

```yaml
toss:
  payments:
    client-key: ${TOSS_CLIENT_KEY}   # 프론트엔드용
    secret-key: ${TOSS_SECRET_KEY}   # 백엔드용 (절대 노출 금지!)
```

### 1.3 설정 클래스 생성

```java
// TossPaymentProperties.java
@ConfigurationProperties(prefix = "toss.payments")
public record TossPaymentProperties(
    String clientKey,
    String secretKey
) {}

// 메인 클래스에 추가
@EnableConfigurationProperties(TossPaymentProperties.class)
```

---

## Step 2: 토스페이먼츠 API 클라이언트

### 2.1 RestClient 설정

```java
@Configuration
public class TossPaymentConfig {

    @Bean
    public RestClient tossPaymentRestClient(TossPaymentProperties properties) {
        // Secret Key를 Base64로 인코딩
        String encodedKey = Base64.getEncoder()
            .encodeToString((properties.secretKey() + ":").getBytes());

        return RestClient.builder()
            .baseUrl("https://api.tosspayments.com/v1")
            .defaultHeader("Authorization", "Basic " + encodedKey)
            .defaultHeader("Content-Type", "application/json")
            .build();
    }
}
```

### 2.2 API 클라이언트 구현

```java
@Component
@RequiredArgsConstructor
public class TossPaymentClient {

    private final RestClient tossPaymentRestClient;

    // 빌링키 발급
    public TossBillingKeyResponse issueBillingKey(String authKey, String customerKey) {
        TossBillingKeyRequest request = new TossBillingKeyRequest(authKey, customerKey);

        return tossPaymentRestClient.post()
            .uri("/billing/authorizations/issue")
            .body(request)
            .retrieve()
            .body(TossBillingKeyResponse.class);
    }

    // 빌링키로 결제
    public TossPaymentResponse billingPayment(
            String billingKey,
            String customerKey,
            int amount,
            String orderId,
            String orderName) {

        TossBillingPaymentRequest request = new TossBillingPaymentRequest(
            customerKey, amount, orderId, orderName
        );

        return tossPaymentRestClient.post()
            .uri("/billing/{billingKey}", billingKey)
            .body(request)
            .retrieve()
            .body(TossPaymentResponse.class);
    }
}
```

---

## Step 3: DTO 정의

### 3.1 요청 DTO

```java
// 빌링키 발급 요청
public record TossBillingKeyRequest(
    String authKey,
    String customerKey
) {}

// 빌링키 결제 요청
public record TossBillingPaymentRequest(
    String customerKey,
    int amount,
    String orderId,
    String orderName
) {}
```

### 3.2 응답 DTO

```java
// 빌링키 발급 응답
public record TossBillingKeyResponse(
    String billingKey,
    String customerKey,
    String authenticatedAt,
    String method,
    TossCardInfo card
) {}

// 결제 응답
public record TossPaymentResponse(
    String paymentKey,
    String orderId,
    String status,
    String approvedAt,
    int totalAmount,
    String method,
    TossCardInfo card
) {}

// 카드 정보
public record TossCardInfo(
    String issuerCode,
    String number,
    String cardType
) {}
```

---

## Step 4: 엔티티 수정

### 4.1 User 엔티티에 필드 추가

```java
@Entity
public class User {
    // 기존 필드...

    @Column(name = "billing_key", length = 200)
    private String billingKey;  // 빌링키 저장

    @Column(name = "subscription_cancelled")
    private boolean subscriptionCancelled;  // 구독 취소 여부

    // 구독 시작
    public void upgradeToPremium(LocalDateTime expiresAt, String billingKey) {
        this.subscriptionType = SubscriptionType.PREMIUM;
        this.subscriptionExpiresAt = expiresAt;
        this.billingKey = billingKey;
        this.subscriptionCancelled = false;
    }

    // 구독 취소 (즉시 해지X, 만료일까지 유지)
    public void cancelSubscription() {
        this.subscriptionCancelled = true;
    }

    // 만료 후 다운그레이드
    public void downgradeToFree() {
        this.subscriptionType = SubscriptionType.FREE;
        this.subscriptionExpiresAt = null;
        this.billingKey = null;
        this.subscriptionCancelled = false;
    }
}
```

---

## Step 5: 서비스 구현

### 5.1 결제 준비 (customerKey 생성)

```java
public PaymentPrepareResponse preparePayment(String email, String planType) {
    User user = userRepository.findByEmail(email)
        .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));

    // customerKey 생성 (UUID 또는 사용자 고유값)
    String customerKey = "user_" + user.getId() + "_" + UUID.randomUUID();

    return new PaymentPrepareResponse(
        customerKey,
        9900,  // 금액
        "Premium 월간 구독",
        user.getEmail(),
        user.getNickname()
    );
}
```

### 5.2 빌링키 발급 및 첫 결제

```java
@Transactional
public BillingKeyIssueResponse issueBillingKeyAndPay(String email, BillingKeyIssueRequest request) {
    User user = userRepository.findByEmail(email)
        .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));

    // 1. 빌링키 발급
    String customerKey = "user_" + user.getId();
    TossBillingKeyResponse billingResponse = tossPaymentClient.issueBillingKey(
        request.authKey(), customerKey
    );

    // 2. 첫 결제 실행
    String orderId = "ORDER_" + System.currentTimeMillis();
    TossPaymentResponse paymentResponse = tossPaymentClient.billingPayment(
        billingResponse.billingKey(),
        customerKey,
        9900,
        orderId,
        "Premium 월간 구독"
    );

    // 3. 결제 기록 저장
    Payment payment = Payment.builder()
        .user(user)
        .orderId(orderId)
        .paymentKey(paymentResponse.paymentKey())
        .amount(9900)
        .status(PaymentStatus.COMPLETED)
        .build();
    paymentRepository.save(payment);

    // 4. 사용자 구독 업그레이드
    LocalDateTime expiresAt = LocalDateTime.now().plusDays(30);
    user.upgradeToPremium(expiresAt, billingResponse.billingKey());

    return new BillingKeyIssueResponse(
        payment.getId(),
        billingResponse.card().number(),
        expiresAt.toString()
    );
}
```

### 5.3 구독 취소

```java
@Transactional
public SubscriptionCancelResponse cancelSubscription(String email) {
    User user = userRepository.findByEmail(email)
        .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));

    if (user.getSubscriptionType() != SubscriptionType.PREMIUM) {
        throw new BusinessException(ErrorCode.SUBSCRIPTION_NOT_FOUND);
    }

    if (user.isSubscriptionCancelled()) {
        throw new BusinessException(ErrorCode.SUBSCRIPTION_ALREADY_CANCELLED);
    }

    user.cancelSubscription();

    return new SubscriptionCancelResponse(
        "구독이 취소되었습니다. 만료일까지 서비스를 이용할 수 있습니다.",
        user.getSubscriptionExpiresAt().toString()
    );
}
```

---

## Step 6: 자동 갱신 스케줄러

### 6.1 정기결제 처리

```java
@Component
@RequiredArgsConstructor
public class PaymentScheduler {

    private final UserRepository userRepository;
    private final PaymentService paymentService;

    // 매일 오전 9시 실행
    @Scheduled(cron = "0 0 9 * * *")
    @Transactional
    public void processRecurringPayments() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime tomorrow = now.plusDays(1);

        // 만료 예정 + 취소 안함 + 빌링키 있는 사용자
        List<User> users = userRepository.findUsersForRecurringPayment(now, tomorrow);

        for (User user : users) {
            try {
                paymentService.processRecurringPayment(user);
            } catch (Exception e) {
                // 결제 실패 시 다운그레이드
                user.downgradeToFree();
                log.error("정기결제 실패: userId={}", user.getId(), e);
            }
        }
    }

    // 매일 자정: 취소된 구독 중 만료된 것 다운그레이드
    @Scheduled(cron = "0 0 0 * * *")
    @Transactional
    public void downgradeExpiredSubscriptions() {
        int count = userRepository.downgradeExpiredCancelledUsers();
        log.info("만료된 구독 다운그레이드: {} 명", count);
    }
}
```

### 6.2 Repository 쿼리

```java
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u WHERE u.subscriptionType = 'PREMIUM' " +
           "AND u.subscriptionCancelled = false " +
           "AND u.billingKey IS NOT NULL " +
           "AND u.subscriptionExpiresAt BETWEEN :now AND :tomorrow")
    List<User> findUsersForRecurringPayment(
        @Param("now") LocalDateTime now,
        @Param("tomorrow") LocalDateTime tomorrow
    );

    @Modifying
    @Query("UPDATE User u SET u.subscriptionType = 'FREE', " +
           "u.subscriptionExpiresAt = null, u.billingKey = null, " +
           "u.subscriptionCancelled = false " +
           "WHERE u.subscriptionType = 'PREMIUM' " +
           "AND u.subscriptionCancelled = true " +
           "AND u.subscriptionExpiresAt < CURRENT_TIMESTAMP")
    int downgradeExpiredCancelledUsers();
}
```

---

## Step 7: 프론트엔드 구현

### 7.1 토스페이먼츠 SDK 로드 (index.html)

```html
<script src="https://js.tosspayments.com/v2/standard"></script>
```

### 7.2 타입 정의 (toss.d.ts)

```typescript
interface TossPaymentWidget {
  requestBillingKeyAuth(
    method: '카드',
    options: {
      scope: 'BILLING';
      customerEmail?: string;
      customerName?: string;
      successUrl: string;
      failUrl: string;
    }
  ): Promise<void>;
}

interface TossPaymentsInstance {
  payment(options: { customerKey: string }): TossPaymentWidget;
}

interface Window {
  TossPayments: (clientKey: string) => TossPaymentsInstance;
}
```

### 7.3 결제 요청 (PaymentPage.tsx)

```typescript
const handlePayment = async () => {
  try {
    // 1. 클라이언트 키 조회
    const clientKey = await getClientKey();

    // 2. 결제 준비 (customerKey 생성)
    const prepareResponse = await preparePayment('PREMIUM_MONTHLY');

    // 3. 토스페이먼츠 SDK 초기화
    const tossPayments = window.TossPayments(clientKey);
    const payment = tossPayments.payment({
      customerKey: prepareResponse.customerKey
    });

    // 4. 빌링키 인증 요청 (결제창 열림)
    await payment.requestBillingKeyAuth('카드', {
      scope: 'BILLING',
      customerEmail: prepareResponse.customerEmail,
      customerName: prepareResponse.customerName,
      successUrl: `${window.location.origin}/payment/success`,
      failUrl: `${window.location.origin}/payment/fail`,
    });
  } catch (err) {
    console.error('결제 요청 실패:', err);
  }
};
```

### 7.4 결제 완료 처리 (PaymentSuccessPage.tsx)

```typescript
export default function PaymentSuccessPage() {
  const [searchParams] = useSearchParams();
  const authKey = searchParams.get('authKey');  // 토스에서 전달받음

  useEffect(() => {
    if (!authKey) return;

    const processPayment = async () => {
      try {
        // 백엔드에 authKey 전달 → 빌링키 발급 + 첫 결제
        const response = await issueBillingKey({ authKey });

        // 사용자 정보 갱신
        const updatedUser = await userApi.getMyProfile();
        setUser(updatedUser);
      } catch (err) {
        console.error('결제 승인 실패:', err);
      }
    };

    processPayment();
  }, [authKey]);

  // ... 성공/실패 UI
}
```

---

## Step 8: 구독 취소 UI

### 8.1 MyPage에서 취소 버튼

```typescript
const handleCancelSubscription = async () => {
  try {
    await cancelSubscription();

    // 사용자 정보 갱신
    const updatedUser = await userApi.getMyProfile();
    setUser(updatedUser);
  } catch (err) {
    console.error('구독 취소 실패:', err);
  }
};

// JSX
{user?.subscriptionType === 'PREMIUM' && !user?.subscriptionCancelled && (
  <button onClick={() => setShowCancelModal(true)}>
    구독 취소
  </button>
)}

{user?.subscriptionCancelled && (
  <span>구독 취소됨 - {user.subscriptionExpiresAt}까지 이용 가능</span>
)}
```

---

## 정리: 주요 흐름

### 결제 흐름
1. 프론트: 결제 버튼 클릭
2. 백엔드: customerKey 생성
3. 프론트: 토스 SDK로 결제창 호출
4. 사용자: 카드 정보 입력
5. 토스: authKey를 successUrl로 전달
6. 프론트: authKey를 백엔드에 전달
7. 백엔드: authKey → 빌링키 발급 → 첫 결제 → 구독 활성화

### 자동 갱신 흐름
1. 스케줄러: 매일 만료 예정 사용자 조회
2. 빌링키로 자동 결제
3. 구독 기간 30일 연장

### 구독 취소 흐름
1. 사용자: 취소 버튼 클릭
2. 백엔드: subscriptionCancelled = true
3. 만료일까지 서비스 이용 가능
4. 만료 후 스케줄러가 FREE로 다운그레이드
