# 로그인 API 설계 결정사항

> 작성일: 2024-12-13
> Phase: 2 (인증 시스템) - Task 6

---

## 1. 설계 질문 및 결정

### Q1. 로그인 응답에 포함할 정보?

**결정**: Access Token + 사용자 정보(이메일, 닉네임) 포함

**이유**:
- 로그인 직후 프론트엔드에서 사용자 정보 표시 필요
- 별도 API 호출 없이 바로 UI 렌더링 가능
- 네트워크 요청 1회 절약

---

### Q2. 이메일 미인증 사용자 처리?

**결정**: 로그인 차단 (비회원 처리)

**이유**:
- 이메일 인증 = 실제 사용자 확인
- 미인증 상태로 서비스 이용 시 스팸/어뷰징 위험
- 보안 강화

**구현 방식**:
```
if (!user.isEmailVerified()) {
    throw new CustomException(ErrorCode.EMAIL_NOT_VERIFIED);
}
```

---

### Q3. 로그아웃 방식?

**결정**: Task 6에서는 클라이언트 측 토큰 삭제, Task 7에서 Refresh Token + 블랙리스트 구현

**이유**:
- JWT는 Stateless → 서버에서 즉시 무효화 불가
- 학습 단계별 진행 (Access Token → Refresh Token → 블랙리스트)
- Task 7에서 Redis 사용한 토큰 관리 학습

**Task 6 범위**:
- 로그아웃 엔드포인트 생성 (형식적)
- 프론트엔드에서 토큰 삭제 안내

**Task 7 범위**:
- Refresh Token 저장 (Redis)
- 로그아웃 시 Refresh Token 삭제/블랙리스트

---

### Q4. 로그인 실패 메시지 구분?

**결정**: 이메일 없음 vs 비밀번호 틀림 구분

**이유**:
- 학습 목적: 에러 코드 체계화 연습
- 사용자 경험: 명확한 피드백 제공
- 실무에서는 보안상 동일 메시지 권장 (열거 공격 방지)

**에러 코드 추가 필요**:
| 코드 | 이름 | 메시지 |
|------|------|--------|
| 2003 | USER_NOT_FOUND | 존재하지 않는 이메일입니다 |
| 2004 | INVALID_PASSWORD | 비밀번호가 일치하지 않습니다 |
| 2005 | EMAIL_NOT_VERIFIED | 이메일 인증이 필요합니다 |

---

## 2. 보안 참고사항 (실무)

### 열거 공격 (Enumeration Attack)
- 공격자가 이메일 존재 여부를 파악하는 공격
- 방지: "이메일 또는 비밀번호가 일치하지 않습니다" 동일 메시지 사용

### 현재 프로젝트
- 학습 목적이므로 구분된 메시지 사용
- 실무 적용 시 통합 메시지로 변경 권장

---

## 3. Task 6 구현 범위

1. **LoginRequest DTO** - 이메일, 비밀번호
2. **LoginResponse DTO** - Access Token, 사용자 정보
3. **AuthService.login()** - 로그인 로직
4. **AuthController POST /login** - 로그인 엔드포인트
5. **AuthController POST /logout** - 로그아웃 엔드포인트 (형식적)
6. **ErrorCode 추가** - USER_NOT_FOUND, INVALID_PASSWORD, EMAIL_NOT_VERIFIED
