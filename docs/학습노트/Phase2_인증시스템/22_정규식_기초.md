# 정규식(Regular Expression) 기초

> 문자열 패턴을 정의하고 검증하는 표현식

---

## 1. 정규식이란?

정규식(Regex)은 문자열에서 특정 패턴을 찾거나, 유효성을 검증할 때 사용하는 표현식입니다.

```javascript
// JavaScript에서 정규식 사용
const regex = /^[a-z]+$/;  // 소문자만 허용
regex.test('hello');       // true
regex.test('Hello');       // false
```

---

## 2. 기본 문법

### 2.1 리터럴 문자
일반 문자는 그 자체로 매칭됩니다.

```javascript
/hello/.test('hello world');  // true
/abc/.test('abcdef');         // true
```

### 2.2 메타 문자 (특수 의미)

| 문자 | 의미 | 예시 |
|------|------|------|
| `.` | 아무 문자 1개 (줄바꿈 제외) | `/a.c/` → "abc", "a1c" |
| `^` | 문자열 시작 | `/^hello/` → "hello world" |
| `$` | 문자열 끝 | `/world$/` → "hello world" |
| `\` | 이스케이프 | `/\./` → "." 문자 자체 |

### 2.3 문자 클래스 `[]`

대괄호 안의 문자 중 하나와 매칭됩니다.

```javascript
/[abc]/.test('a');      // true (a, b, c 중 하나)
/[a-z]/.test('x');      // true (a부터 z까지)
/[A-Z]/.test('X');      // true (대문자)
/[0-9]/.test('5');      // true (숫자)
/[a-zA-Z]/.test('A');   // true (모든 영문자)
```

**부정 문자 클래스 `[^]`:**
```javascript
/[^0-9]/.test('a');     // true (숫자가 아닌 것)
/[^a-z]/.test('A');     // true (소문자가 아닌 것)
```

### 2.4 축약 문자 클래스

| 축약 | 의미 | 동등 표현 |
|------|------|-----------|
| `\d` | 숫자 | `[0-9]` |
| `\D` | 숫자 아님 | `[^0-9]` |
| `\w` | 단어 문자 | `[a-zA-Z0-9_]` |
| `\W` | 단어 문자 아님 | `[^a-zA-Z0-9_]` |
| `\s` | 공백 | `[ \t\n\r\f]` |
| `\S` | 공백 아님 | `[^ \t\n\r\f]` |

```javascript
/\d/.test('123');       // true
/\w+/.test('hello_1');  // true
/\s/.test(' ');         // true
```

---

## 3. 수량자 (Quantifiers)

패턴의 반복 횟수를 지정합니다.

| 수량자 | 의미 | 예시 |
|--------|------|------|
| `*` | 0회 이상 | `/ab*/` → "a", "ab", "abbb" |
| `+` | 1회 이상 | `/ab+/` → "ab", "abbb" (not "a") |
| `?` | 0회 또는 1회 | `/ab?/` → "a", "ab" |
| `{n}` | 정확히 n회 | `/a{3}/` → "aaa" |
| `{n,}` | n회 이상 | `/a{2,}/` → "aa", "aaa", "aaaa" |
| `{n,m}` | n회 이상 m회 이하 | `/a{2,4}/` → "aa", "aaa", "aaaa" |

```javascript
/^a{3}$/.test('aaa');     // true (정확히 3개)
/^a{2,4}$/.test('aaa');   // true (2~4개)
/.{8,}/.test('12345678'); // true (8자 이상)
```

---

## 4. 그룹과 참조

### 4.1 캡처 그룹 `()`

```javascript
const regex = /(\d{4})-(\d{2})-(\d{2})/;
const match = '2024-01-15'.match(regex);
// match[0] = '2024-01-15' (전체)
// match[1] = '2024' (첫 번째 그룹)
// match[2] = '01' (두 번째 그룹)
// match[3] = '15' (세 번째 그룹)
```

### 4.2 비캡처 그룹 `(?:)`
그룹화만 하고 캡처하지 않음:

```javascript
/(?:ab)+/.test('abab');  // true (그룹화만, 캡처 안 함)
```

---

## 5. 전방탐색 (Lookahead)

### 5.1 긍정 전방탐색 `(?=...)`
해당 패턴이 뒤따르는지 확인 (매칭에 포함 안 됨):

```javascript
// "foo" 뒤에 "bar"가 있는 경우
/foo(?=bar)/.test('foobar');  // true
/foo(?=bar)/.test('foobaz');  // false
```

### 5.2 부정 전방탐색 `(?!...)`
해당 패턴이 뒤따르지 않는지 확인:

```javascript
// "foo" 뒤에 "bar"가 없는 경우
/foo(?!bar)/.test('foobaz');  // true
/foo(?!bar)/.test('foobar');  // false
```

---

## 6. 비밀번호 정규식 분석

프로젝트에서 사용하는 비밀번호 정규식:

```javascript
const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*(),.?":{}|<>]).{8,}$/;
```

### 분해 분석

| 부분 | 의미 |
|------|------|
| `^` | 문자열 시작 |
| `(?=.*[a-z])` | 소문자가 최소 1개 있어야 함 (전방탐색) |
| `(?=.*[A-Z])` | 대문자가 최소 1개 있어야 함 (전방탐색) |
| `(?=.*\d)` | 숫자가 최소 1개 있어야 함 (전방탐색) |
| `(?=.*[!@#$%^&*(),.?":{}|<>])` | 특수문자가 최소 1개 있어야 함 |
| `.{8,}` | 아무 문자나 8개 이상 |
| `$` | 문자열 끝 |

### 전방탐색이 왜 필요한가?

전방탐색 없이 순서대로 매칭하면:
```javascript
/[a-z][A-Z]\d/  // 소문자 → 대문자 → 숫자 순서로만 매칭
```

전방탐색을 사용하면 **순서와 무관하게** 조건만 확인:
```javascript
/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/  // 순서 상관없이 모두 포함되면 OK
```

### 테스트 예시

```javascript
const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*(),.?":{}|<>]).{8,}$/;

regex.test('Password1!');    // true ✅
regex.test('password1!');    // false ❌ (대문자 없음)
regex.test('PASSWORD1!');    // false ❌ (소문자 없음)
regex.test('Password!!');    // false ❌ (숫자 없음)
regex.test('Password1');     // false ❌ (특수문자 없음)
regex.test('Pass1!');        // false ❌ (8자 미만)
```

---

## 7. 이메일 정규식

```javascript
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
```

| 부분 | 의미 |
|------|------|
| `^[^\s@]+` | 시작, 공백/@가 아닌 문자 1개 이상 |
| `@` | @ 문자 |
| `[^\s@]+` | 공백/@가 아닌 문자 1개 이상 |
| `\.` | . 문자 (이스케이프) |
| `[^\s@]+$` | 공백/@가 아닌 문자 1개 이상, 끝 |

```javascript
emailRegex.test('user@example.com');     // true
emailRegex.test('user.name@domain.co');  // true
emailRegex.test('invalid@');             // false
emailRegex.test('@domain.com');          // false
```

---

## 8. 자주 사용하는 정규식

### 한글만
```javascript
/^[가-힣]+$/
```

### 영문만
```javascript
/^[a-zA-Z]+$/
```

### 영문 + 숫자
```javascript
/^[a-zA-Z0-9]+$/
```

### 휴대폰 번호 (한국)
```javascript
/^01[0-9]-\d{3,4}-\d{4}$/
```

### URL
```javascript
/^https?:\/\/.+/
```

---

## 9. JavaScript 정규식 메서드

### `test()` - 매칭 여부 확인
```javascript
/hello/.test('hello world');  // true
```

### `match()` - 매칭 결과 반환
```javascript
'hello world'.match(/\w+/g);  // ['hello', 'world']
```

### `replace()` - 치환
```javascript
'hello world'.replace(/world/, 'regex');  // 'hello regex'
```

### `split()` - 분리
```javascript
'a,b;c'.split(/[,;]/);  // ['a', 'b', 'c']
```

---

## 10. 정규식 플래그

| 플래그 | 의미 |
|--------|------|
| `g` | 전역 검색 (모든 매칭) |
| `i` | 대소문자 무시 |
| `m` | 멀티라인 (^, $가 각 줄에 적용) |

```javascript
/hello/i.test('HELLO');       // true (대소문자 무시)
'aa bb aa'.match(/aa/g);      // ['aa', 'aa'] (전역 검색)
```

---

## 11. 이스케이프가 필요한 문자

다음 문자들은 특수 의미가 있어서 리터럴로 사용하려면 `\`로 이스케이프:

```
. * + ? ^ $ { } [ ] ( ) | \
```

```javascript
/1\+1/.test('1+1');    // true (+ 리터럴)
/\[a\]/.test('[a]');   // true ([] 리터럴)
/\$100/.test('$100');  // true ($ 리터럴)
```

**팁:** 문자 클래스 `[]` 안에서는 대부분 이스케이프 불필요:
```javascript
/[.+*]/.test('+');     // true ([] 안에서는 리터럴)
```

---

## 관련 키워드
- Regular Expression
- Regex
- Pattern Matching
- Lookahead
- Character Class
- Quantifier
- 비밀번호 유효성 검사

